<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Welch!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Első osztályom</title>
        <para>
            Valósítsd meg C++-ban és Java-ban az módosított polártranszformációs algoritmust! A matek háttér 
            teljesen irreleváns, csak annyiban érdekes, hogy az algoritmus egy számítása során két normálist
            számol ki, az egyiket elspájzolod és egy további logikai taggal az osztályban jelzed, hogy van vagy
            nincs eltéve kiszámolt szám.
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            <link xlink:href="https://github.com/pkristof1999/prog1/tree/master/Feladatok/Polártranszformációs%20Algoritmus">Első osztályom (a mappa tartalmazza a java és a c++ forrásokat is)(Forrás: UDPROG)</link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>  
        <para>
            Ebben a programban polártranszformáció segítségével véletlenszerű számokat tudunk kiszámolni. A Java véletlenszerű-szám generátora is ezt használja.
            A polártanszformációs algoritmus két "véletlen" értéket generál. A megadott forrásokat összehasonlítva rájöhetünk, hogy a java kódja egyszerűbb és átláthatóbb.
        </para>
    </section>        

    <section>
        <title>LZW</title>
        <para>
            Valósítsd meg C-ben az LZW algoritmus fa-építését!
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            <link xlink:href="https://github.com/pkristof1999/prog1/tree/master/Feladatok/BinFa">LZW (Forrás: UDPROG)</link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>
            Maga az LZW fa lényege, hogy futás közben egy általunk megadott szöveges dokumentum sorait fogjuk beolvasni, 
            és ezeket az értékeket bináris kóddá alakítjuk, amelyeket egymásba ágyazott for ciklusokkal rendezünk.
            A program természetesen addig olvas, amíg van nem üres sor és úgy építi fel a fát, hogy
            mindig leellenőrzi azt, hogy van-e 1-es vagy 0-ás gyermek, ha nincs akkor létrehozza azt, majd visszaugrik a
            gyökérre. Ellenkező esetben az 1-es és a 0-ás gyermekre lép, és mindaddig lépked a fában, ameddig nem talál
            egy olyan részfát, ahol létre kellene hozni egy új gyermeket. Ezekután visszaugrik a gyökérre.
        </para>
    </section>        
        
    <section>
        <title>Fabejárás</title>
        <para>
            Járd be az előző (inorder bejárású) fát pre- és posztorder is!
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            <link xlink:href="https://github.com/pkristof1999/prog1/tree/master/Feladatok/BinFa">LZW (preorder/posztorder)(Forrás: UDPROG)</link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>
            Ez a feladat megegyezik az előző feladattal, különbség a bejárási mintában keresendő.
            Míg az alapnak tekinthető Inorder (amely az előző feladatban is megoldásul szolgált) bejárási formálya a következő: Inorder (Left, Root, Right),
            addig a Posztorderé: Postorder (Left, Right, Root), valaint a Preorderé pedig: Preorder (Root, Left, Right).
            Forrás: <link xlink:href="https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/">https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/</link>
        </para>
    </section>        
                        
    <section>
        <title>Tag a gyökér</title>
        <para>
            Az LZW algoritmust ültesd át egy C++ osztályba, legyen egy Tree és egy beágyazott Node
            osztálya. A gyökér csomópont legyen kompozícióban a fával!
        </para>
        
        <para>
            Megoldás forrása:                
        </para>
        <para>
            <link xlink:href="https://github.com/pkristof1999/prog1/tree/master/Feladatok/BinFa">Tag a gyökér</link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>
            A fát felépítő algoritmus megegyezik az előzővel, annyi az eltérés, hogy nem hívunk meg szokásos formát az építéshez,
            hanem egyszerűen bele "shifteljük" az elemeket a fába.
        </para>
    </section>        
                
    <section>
        <title>Mutató a gyökér</title>
        <para>
            Írd át az előző forrást, hogy a gyökér csomópont ne kompozícióban, csak aggregációban legyen a 
            fával!
        </para>
        <para>
            Megoldás forrása:  
        </para>
        <para>
            <link xlink:href="https://github.com/pkristof1999/prog1/tree/master/Feladatok/BinFa">Mutató a gyökér</link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>
            Át kell állítsuk a gyökér létrehozását, a "Heapen" fogunk allokálni neki helyett a "Stack" helyett. Le kell, hogy vegyük az iniciliazálási
            listát, mivel a Node konstruktora fog később lefutni.
            Egyetlen utasítással kell bővítenünk a "desktruktort", mégpedig "delete gyoker" a felszabadítások végén.
        </para>
    </section>                     

    <section>
        <title>Mozgató szemantika</title>
        <para>
            Írj az előző programhoz mozgató konstruktort és értékadást, a mozgató konstruktor legyen a mozgató
            értékadásra alapozva!
        </para>
        <para>
            Megoldás forrása:  
        </para>
        <para>
            <link xlink:href="https://github.com/pkristof1999/prog1/tree/master/Feladatok/BinFa">Mozgató szemantika</link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>
            Az előző feladatot alapul véve implementáljuk bele a mozgató és mozgató-értékadás alapú konstruktorokat.   
            Mozgató konstruktornál "nullptr"-re állítjuk a BinFa gyökerét, majd erre a BinFára rávisszük az "other"
            nevű fát, mely lényege, hogy a kapott "lvalue"-ból "rvalue"-t készít, így átvisszük az összes adatát az új fába,
            ezért felszabadul az a memória, amelyet eddig foglalt és kiürül az "other".
        </para>
    </section>                     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
